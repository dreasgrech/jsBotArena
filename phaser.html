<!DOCTYPE html>
<html>
<head>
    <script src="phaser-3.15.1.js"></script>
</head>
<body>

<script>
    var GAME_WIDTH = 1024,
        GAME_HEIGHT = 1024;

    var gameContext;

    const PhysicsCategories = (function() {
        var categories = [
            'RobotBody',
            'RobotTurret',
            'Walls'
        ];

        // Assign the correct 2^n value to each category
        var physicsCategories = {};
        for (var i = 0; i < categories.length; i++) {
            physicsCategories[categories[i]] = Math.pow(2, i);
        }

        return physicsCategories;
    }());

    var RobotAPIFactory = (function() {
        var createAPI = function(robotIndex) {
            return (function (robotIndex) {

                var constantAngularVelocityForRotation = 0.05;

                var move = function(direction) {
                    var tankBody = RobotsData.robotBodyImages[robotIndex];
                    var tankSpeed = RobotsData.robotSpeeds[robotIndex];

                    var angle = tankBody.angle - 90; // The '- 90' is because of Phaser's coordinate system where angle 0 points to the right
                    var angleRadians = Phaser.Math.DegToRad(angle);

                    //console.log(angle);
                    var force = new Phaser.Math.Vector2(Math.cos(angleRadians) * tankSpeed * direction, Math.sin(angleRadians) * tankSpeed * direction); // * tankSpeed;
                    tankBody.applyForce(force);
                    // tankBody.thrust(0.1);
                };

                var moveForward = function() {
                    move(1);
                };

                var moveReverse = function() {
                    move(-1);
                };

                var rotate = function(direction) {
                    var tankBody = RobotsData.robotBodyImages[robotIndex];
                    var angularVelocity = constantAngularVelocityForRotation*direction; 
                
                    tankBody.setAngularVelocity(angularVelocity);
                };

                var rotateLeft = function(direction) {
                    rotate(1);
                };

                var rotateRight  = function(direction) {
                    rotate(-1);
                };

                return {
                    move: moveForward,
                    reverse: moveReverse,
                    rotateLeft: rotateLeft,
                    rotateRight: rotateRight
                };
            }(robotIndex));
        };

        return {
            createAPI: createAPI
        };
    }());

    var gameManager = (function() {

        var preload = function() {
            gameContext = this;

            ImageDatabase.loadAllImages();

            // var floor = this.load.image('arena_floor', 'images/arena_floor.png');
            this.load.image('floor_image', 'images/Floor - Dirt 2 64x64.png');
            this.load.image('wall_image', 'images/Wall - Brick 2 64x64.png');

            this.load.tilemapTiledJSON('arena_json', 'arena_map.json');
        };

        var create = function() {
            // Enable Matter physics
            this.matter.world.setBounds();
            /*
                var floorImage = this.textures.get('arena_floor').getSourceImage();
                var floorImageWidth = floorImage.width;
                var floorImageHeight = floorImage.height;
        
                console.log(floorImageWidth);
                console.log(floorImageHeight);
        
                var posX = 0, posY = 0;
                var floor = this.add.tileSprite(posX, posY, GAME_WIDTH, GAME_HEIGHT, "arena_floor");
                floor.setOrigin(0, 0);
            */

            //this.add.image(0, 0, 'floor');
            var map = this.make.tilemap({ key: 'arena_json' });

            var floorTilesetImage = map.addTilesetImage('Floor', 'floor_image');
            var wallTilesetImage = map.addTilesetImage('Walls', 'wall_image');

            var floorLayer = map.createStaticLayer('Floor Layer', floorTilesetImage);
            var wallsLayer = map.createStaticLayer('Walls Layer', wallTilesetImage);

            // Set collision on the walls
            // wallsLayer.setCollisionByProperty({ collides: true });
            var matterBodies = PhysicsHelperFunctions.createMatterBodiesFromTilemapLayer(wallsLayer, PhysicsCategories.Walls, PhysicsCategories.RobotBody);
            PhysicsBodies.addArenaBodies(matterBodies); // Add all the bodies from the arena to the arena bodies collection

            // helperFunctions.showDebugLayerCollisions(wallsLayer);

            robotManager.addRobot(shredder);
            robotManager.addRobot(circleBot);
        };


        var update = function(time, delta) {
            robotManager.update(time, delta);
        };

        return {
            preload: preload,
            create: create,
            update: update
        }
    }());

    var RobotsData = (function() {
        var ids = [];
        var positionXs = [];
        var positionYs = [];
        var updateFunctions = [];
        var robotBodyImages = [];
        var robotTurretImages = [];
        var robotAPIs = [];
        var robotSpeeds = [];

        return {
            ids: ids,
            positionXs: positionXs,
            positionYs: positionYs,
            updateFunctions: updateFunctions,
            robotBodyImages: robotBodyImages,
            robotTurretImages: robotTurretImages,
            robotAPIs: robotAPIs,
            robotSpeeds: robotSpeeds
        };
    }());

    var PhysicsBodies = (function() {
        var arenaBodies = [];
        var arenaBodiesBounds = [];

        var addArenaBodies = function(bodies) {
            var arenaBodiesTotalBeforeAdd = arenaBodies.length;
            arenaBodies = arenaBodies.concat(bodies);
            for (var i = 0; i < bodies.length; i++) {
                //arenaBodiesBounds.push(bodies[i].getBounds());
                var body = bodies[i];
            //    var tankAABB = new Phaser.Geom.Rectangle(
            //        body.bounds.min.x,
            //        body.bounds.min.y,
            //        body.bounds.max.x - body.bounds.min.x,
            //        body.bounds.max.y - body.bounds.min.y
            //    );
            }
            console.assert( arenaBodies.length === arenaBodiesTotalBeforeAdd + bodies.length, "Make sure that all the elements were added");
        };

        function computeAABB(vertices) {
            let minX = vertices[0].x;
            let maxX = vertices[0].x;
            let minY = vertices[0].y;
            let maxY = vertices[0].y;

            for (let i = 1; i < vertices.length; i++) {
                minX = Math.min(minX, vertices[i].x);
                maxX = Math.max(maxX, vertices[i].x);
                minY = Math.min(minY, vertices[i].y);
                maxY = Math.max(maxY, vertices[i].y);
            }

            return new Phaser.Geom.Rectangle(minX, minY, maxX - minX, maxY - minY);
        }

        var isBodyOverlappingWithArenaBodies = function(body) {
            var bodyBounds = Phaser.GameObjects.Components.GetBounds.getBounds(body);
            console.log(bodyBounds);
            return false;
            /*
            // const tankAABB = computeAABB(body.vertices);
            // console.log(tankAABB);
            //console.log(body.parts);
            var bodyBounds = Phaser.GameObjects.Components.GetBounds.getBounds(body);
            console.log(bodyBounds.body.vertices);

// Phaser.Physics.Matter.Matter.Bounds.overlaps(tankBody.bounds, existingTankBody.bounds)
            //if (Phaser.Physics.Matter.Matter.Bounds.overlaps(tankBody.bounds, existingTankBody.bounds))


            for (var i = 0; i < arenaBodies.length; i++) {
                var arenaBody = arenaBodies[i];
                var arenaBodyBounds = Phaser.GameObjects.Components.GetBounds.getBounds(arenaBody);

                var collides = Phaser.Physics.Matter.Matter.Bounds.overlaps(bodyBounds, arenaBodyBounds);
                if (collides) {
                    return true;
                }
            }

            return false;
            */
        };

        return {
            arenaBodies: arenaBodies,
            addArenaBodies: addArenaBodies,
            isBodyOverlappingWithArenaBodies: isBodyOverlappingWithArenaBodies
        };
    }());

    var ImageDatabase = (function() {
        const tankImagesDirectory = 'images/robots';
        const totalHullsColors = 4, totalHullsVariations = 8;
        const totalWeaponsColors = 4, totalWeaponsVariations = 8;

        var loadAllImages = function() {

            // Iterate Hulls colors
            for (var i = 0; i < totalHullsColors; i++) {
                let characterCode = 65 + i; // 'A' = 65, 'B' = 66, etc.
                let directoryName = `Hulls_Color_${String.fromCharCode(characterCode)}`;
                // Iterate Hulls variations
                for (var j = 0; j < totalHullsVariations; j++) {
                    let fileName = `Hull_0${j+1}`;
                    let fullPath = `${tankImagesDirectory}/${directoryName}/${fileName}.png`;

                    let imageIdentifier = `${directoryName}/${fileName}`;
                    //console.log(imageIdentifier);
                    console.log(fullPath);

                    // load the hull image
                    gameContext.load.image(imageIdentifier, fullPath);
                }
            }

            // Iterate weapons colors
            for (var i = 0; i < totalWeaponsColors; i++) {
                var characterCode = 65 + i; // 'A' = 65, 'B' = 66, etc.
                var directoryName = `Weapon_Color_${String.fromCharCode(characterCode)}`;
                // Iterate weapons variations
                for (var j = 0; j < totalWeaponsVariations; j++) {
                    let fileName = `Gun_0${j+1}`;
                    let fullPath = `${tankImagesDirectory}/${directoryName}/${fileName}.png`;

                    let imageIdentifier = `${directoryName}/${fileName}`;
                    //console.log(imageIdentifier);
                    console.log(fullPath);

                    // load the weapon image
                    gameContext.load.image(imageIdentifier, fullPath);
                }
            }
        };

        return {
            loadAllImages: loadAllImages
        };
    }());

    var robotManager = (function() {
        var currentRobotIndex = 0;
        var totalRobots = 0;

        //var placeRobotInArena = function(tankBody) {
        //    var maxAttempts = 10;
        //    var attempts = 0;
        //    var x, y;

        //    while (attempts < maxAttempts && PhysicsBodies.isBodyOverlappingWithArenaBodies(tankBody)) {
        //        // Generate new random position
        //        x = Math.random() * (GAME_WIDTH * 0.7);
        //        y = Math.random() * (GAME_HEIGHT * 0.7);

        //        // Update tankBody position
        //        tankBody.setPosition(x, y);

        //        attempts++;
        //    }

        //    if (attempts >= maxAttempts) {
        //        console.log("Failed to place the tank without overlapping after", maxAttempts, "attempts.");
        //    }
        //};

        var addRobot = function(newRobot) {
            RobotsData.updateFunctions[currentRobotIndex] = newRobot.update;

            var robotScale = 0.4;

            //var gameObject = scene.matter.add.gameObject(gameObject);


            /*****************************/
            // Create tank body and turret
            //var x = Math.random() * (GAME_WIDTH*.7);
            //var y = Math.random() * (GAME_HEIGHT*.7);
            // var tankBody = gameContext.matter.add.image(600, 300, 'tankBody');
            var tankBody = gameContext.matter.add.image(GAME_WIDTH * .5, GAME_HEIGHT * .5, 'Hulls_Color_A/Hull_01');
            tankBody.setScale(robotScale);
            //placeRobotInArena(tankBody);


            tankBody.setAngle(45);
            //tankBody.body.angle = 180;
            // tankBody.angle = 0;
            // tankBody.body.angle = 0;
            tankBody.setFrictionAir(0.2);
            // tankBody.setMass(10);
            tankBody.setMass(100);
            RobotsData.robotBodyImages[currentRobotIndex] = tankBody;
            PhysicsHelperFunctions.setCollisionProperties(tankBody.body, 0, PhysicsCategories.RobotBody, PhysicsCategories.RobotBody | PhysicsCategories.Walls);
            PhysicsBodies.addArenaBodies([tankBody]);
            //console.log("tank group:" + tankBody.body.collisionFilter.group);
            //console.log("tank category:" + tankBody.body.collisionFilter.category);
            //console.log("tank mask:" + tankBody.body.collisionFilter.mask);

            // const tankTurret = this.matter.add.image(400, 300, 'tankTurret');
            var tankTurret = gameContext.matter.add.image(400, 300, 'Weapon_Color_A/Gun_01');
            tankTurret.setScale(robotScale);
            tankTurret.setAngle(0);
            tankTurret.setCollisionCategory(PhysicsCategories.RobotTurret);
            tankTurret.setCollidesWith(0);

            // Set the origin of the turret to the base of the turret
            tankTurret.setOrigin(0.5, 0.75);

            // Create a constraint to attach the turret to the body
            var turretConstraint = gameContext.matter.add.constraint(tankBody, tankTurret, 0, 1);

            RobotsData.robotTurretImages[currentRobotIndex] = tankTurret;

            var api = RobotAPIFactory.createAPI(currentRobotIndex);
            RobotsData.robotAPIs[currentRobotIndex] = api;

            // RobotsData.robotSpeeds[currentRobotIndex] = 0.1;
            // RobotsData.robotSpeeds[currentRobotIndex] = Math.random() * 0.5;
            RobotsData.robotSpeeds[currentRobotIndex] = 0.05;

            //// Update the turret rotation based on pointer location
            /*
            gameContext.input.on('pointermove', (pointer) => {
                // const angle = Phaser.Math.Angle.Between(tankTurret.x, tankTurret.y, pointer.x, pointer.y);
                const angle = Phaser.Math.Angle.Between(tankBody.x, tankBody.y, pointer.x, pointer.y);
                // tankTurret.setAngle(Phaser.Math.RadToDeg(angle));
                tankBody.setAngle(Phaser.Math.RadToDeg(angle));
            });
            */

            // Listen for a pointerdown event to apply force to the tank body
            /*
            gameContext.input.on('pointerdown', () => {
                var forceMagnitude = 0.005; // Change this value to adjust the force applied
                var angle = this.tankTurret.rotation;
                var force = new Phaser.Math.Vector2(Math.cos(angle) * forceMagnitude, Math.sin(angle) * forceMagnitude);
                tankBody.applyForce(force);
            });
            */
            /*****************************/

            totalRobots++;
            currentRobotIndex++;
        };

        var update = function(time, delta) {
            for (var i = 0; i < totalRobots; i++) {
                var updateFunction = RobotsData.updateFunctions[i];
                var api = RobotsData.robotAPIs[i];
                updateFunction(api, time, delta);

                /*
                var tankBody = RobotsData.robotBodyImages[i];
                // controlRobotMovement(tankBody, 0.005); // Adjust the speed as needed
                controlRobotMovement(tankBody);
                */
            }
        };

        return {
            addRobot: addRobot,
            update: update
        };
    }());

    /****************************************/
    var shredder = (function(robotManager) {

        var timeElapsed = 0;
        var interval = 3000; // Move for one second, then stop for two seconds
        var rotateTimer = 0;
        var rotateInterval = 1000; // Rotate every one second

        var update = function(api, time, delta) {
            timeElapsed += delta;
            rotateTimer += delta;

            if (rotateTimer >= rotateInterval)
            {
                if (Math.random() > 0.5) {
                    api.rotateLeft();
                } else {
                    api.rotateRight();
                }
                rotateTimer = 0;
            }

            if (timeElapsed < 1000) { // move
                api.move();
            } else if (timeElapsed < interval) { // stop
                // Do nothing
                api.reverse();
            } else { // Move for one second
                timeElapsed = 0;
            }
            //api.move();
        };

        return {
            update: update
        };
    }(robotManager));

/****************************************/
    var circleBot = (function(robotManager) {

        var forwardSpeed = 1; // Adjust this value to change the forward speed
        var rotationSpeed = 30; // Adjust this value to change the rotation speed

        var update = function(api, time, delta) {
            // Constantly move forward with a custom forward speed
            for (let i = 0; i < forwardSpeed; i++) {
                api.move();
            }

            // Constantly rotate with a custom rotation speed
            for (let i = 0; i < rotationSpeed; i++) {
                api.rotateLeft();
            }
        };

        return {
            update: update
        };
    }(robotManager));
/****************************************/

    var PhysicsHelperFunctions = (function() {
        var setCollisionProperties = function(physicsObject, group, category, collidesWithCategories) {
            physicsObject.collisionFilter.group = group;
            physicsObject.collisionFilter.category = category;
            physicsObject.collisionFilter.mask = collidesWithCategories;
        };

        return {
            // Matter physics does not support tilemap collisions (which is what the arena is made up of).
            // So I created this method with the help of ChatGPT4 which converts the tiles into matter bodies.
            createMatterBodiesFromTilemapLayer: function(layer, collisionCategory, collidesWith) {
                const matterBodies = [];
                layer.forEachTile(tile => {
                    if (tile.properties.collides) {
                        const x = tile.getCenterX();
                        const y = tile.getCenterY();
                        const w = tile.width;
                        const h = tile.height;
                        const body = gameContext.matter.add.rectangle(x, y, w, h, { isStatic: true });
                        // body.collisionFilter.category = PhysicsCategories.Walls;
                        // body.collisionFilter.mask = PhysicsCategories.RobotBody;
                        setCollisionProperties(body, 0, collisionCategory, collidesWith);
                        matterBodies.push(body);
                        // console.log("terrain group:" + body.collisionFilter.group);
                    }
                });

                return matterBodies;
            },
            setCollisionProperties: setCollisionProperties
        };
    }());

    var helperFunctions = (function() {

        // Shows collision on a layer with a different color for debugging.
        // TODO: move this function to PhysicsHelperFunctions
        var showDebugLayerCollisions = function(layer) {
            var debugGraphics = gameContext.add.graphics().setAlpha(0.75);
            layer.renderDebug(debugGraphics,
                {
                    tileColor: null, // Color of non-colliding tiles
                    collidingTileColor: new Phaser.Display.Color(243, 134, 48, 255), // Color of colliding tiles
                    faceColor: new Phaser.Display.Color(40, 39, 37, 255) // Color of colliding face edges
                });
        };

        return {
            showDebugLayerCollisions: showDebugLayerCollisions
        };
    }());

    var config = {
        type: Phaser.AUTO,
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        scene: {
            preload: gameManager.preload,
            create: gameManager.create,
            update: gameManager.update
        },
        physics: {
            default: 'matter',
            matter: {
                debug: true,
                gravity: {
                    x: 0,
                    y: 0
                }
            }
        }
    };
    var game = new Phaser.Game(config);
</script>

</body>
</html>