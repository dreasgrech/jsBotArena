<!DOCTYPE html>
<html>
<head>
    <!--<script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser.js"></script> -->
    <script src="phaser-3.15.1.js"></script>
</head>
<body>

<script>
    var GAME_WIDTH = 1024,
        GAME_HEIGHT = 1024;

    var gameContext;

    const PhysicsCategories = {
        //RobotBody: 2 ^ 0,
        //RobotTurret: 2 ^ 1,
        //Walls: 2 ^ 2
        RobotBody: 2 ^ 0,
        RobotTurret: 2 ^ 0,
        Walls: 2 ^ 0
    };

    var RobotAPIFactory = (function() {
        var createAPI = function(robotIndex) {
            return (function(robotIndex) {
                var setAhead = function(distance) {
                    var tankBody = RobotsData.robotBodyImages[robotIndex];

                    var angle = Phaser.Math.DegToRad(tankBody.angle);
                    // Calculate the target position
                    var targetX = tankBody.x + Math.cos(angle) * distance;
                    var targetY = tankBody.y + Math.sin(angle) * distance;
                    tankBody.targetPosition = new Phaser.Math.Vector2(targetX, targetY);
                    // Set a flag to start moving
                    tankBody.shouldMove = true;

                    //console.log('[' + robotIndex + ']' + ' setAhead: ' + distance + '.  Force: ' + force);
                    // console.log(force);
                };

                return {
                    setAhead: setAhead
                };
            }(robotIndex));
        };

        return {
            createAPI: createAPI
        };
    }());

    var gameManager = (function() {

        var preload = function() {
            gameContext = this;

            // var floor = this.load.image('arena_floor', 'images/arena_floor.png');
            this.load.image('floor_image', 'images/Floor - Dirt 2 64x64.png');
            this.load.image('wall_image', 'images/Wall - Brick 2 64x64.png');

            this.load.tilemapTiledJSON('arena_json', 'arena_map.json');
        };

        var create = function() {
            /*
                var floorImage = this.textures.get('arena_floor').getSourceImage();
                var floorImageWidth = floorImage.width;
                var floorImageHeight = floorImage.height;
        
                console.log(floorImageWidth);
                console.log(floorImageHeight);
        
                var posX = 0, posY = 0;
                var floor = this.add.tileSprite(posX, posY, GAME_WIDTH, GAME_HEIGHT, "arena_floor");
                floor.setOrigin(0, 0);
            */

            //this.add.image(0, 0, 'floor');
            var map = this.make.tilemap({ key: 'arena_json' });

            var floorTilesetImage = map.addTilesetImage('Floor', 'floor_image');
            var wallTilesetImage = map.addTilesetImage('Walls', 'wall_image');

            var floorLayer = map.createStaticLayer('Floor Layer', floorTilesetImage);
            var wallsLayer = map.createStaticLayer('Walls Layer', wallTilesetImage);

            // Set collision on the walls
            wallsLayer.setCollisionByProperty({ collides: true });
            PhysicsHelperFunctions.createMatterBodiesFromTilemapLayer(wallsLayer, PhysicsCategories.Walls, PhysicsCategories.RobotBody);
            /*
            wallsLayer.setCollisionCategory(PhysicsCategories.Walls);
            wallsLayer.setCollidesWith(PhysicsCategories.RobotBody);
            */

            // helperFunctions.showDebugLayerCollisions(wallsLayer);


            /*********************************/
            // Enable Matter physics
            this.matter.world.setBounds();
            /*********************************/

            robotManager.addRobot(shredder);

        };


        var update = function() {
            robotManager.update();
        };

        return {
            preload: preload,
            create: create,
            update: update
        }
    }());

    var RobotsData = (function() {
        var ids = [];
        var positionXs = [];
        var positionYs = [];
        var updateFunctions = [];
        var robotBodyImages = [];
        var robotTurretImages = [];
        var robotAPIs = [];

        return {
            ids: ids,
            positionXs: positionXs,
            positionYs: positionYs,
            updateFunctions: updateFunctions,
            robotBodyImages: robotBodyImages,
            robotTurretImages: robotTurretImages,
            robotAPIs: robotAPIs
        };
    }());

    var robotManager = (function() {
        var currentRobotIndex = 0;
        var totalRobots = 0;

        var addRobot = function(newRobot) {
            RobotsData.updateFunctions[currentRobotIndex] = newRobot.update;

            /*****************************/
            // Create tank body and turret
            var tankBody = gameContext.matter.add.image(400, 300, 'tankBody');
            tankBody.setAngle(-90);
            tankBody.setFrictionAir(0.2);
            // tankBody.setMass(10);
            tankBody.setMass(100);
            tankBody.setCollisionCategory(PhysicsCategories.RobotBody);
            tankBody.setCollidesWith(PhysicsCategories.RobotBody | PhysicsCategories.Walls);
            RobotsData.robotBodyImages[currentRobotIndex] = tankBody;

            // const tankTurret = this.matter.add.image(400, 300, 'tankTurret');
            var tankTurret = gameContext.matter.add.image(400, 300, 'tankTurret');
            tankTurret.setCollisionCategory(PhysicsCategories.RobotTurret);
            tankTurret.setCollidesWith(0);

            // Set the origin of the turret to the base of the turret
            tankTurret.setOrigin(0.5, 0.75);

            // Create a constraint to attach the turret to the body
            var turretConstraint = gameContext.matter.add.constraint(tankBody, tankTurret, 0, 1);

            RobotsData.robotTurretImages[currentRobotIndex] = tankTurret;

            var api = RobotAPIFactory.createAPI(currentRobotIndex);
            RobotsData.robotAPIs[currentRobotIndex] = api;

            //// Update the turret rotation based on pointer location
            gameContext.input.on('pointermove', (pointer) => {
                const angle = Phaser.Math.Angle.Between(tankTurret.x, tankTurret.y, pointer.x, pointer.y);
                tankTurret.setAngle(Phaser.Math.RadToDeg(angle));
                tankBody.setAngle(Phaser.Math.RadToDeg(angle));
            });

            // Listen for a pointerdown event to apply force to the tank body
            /*
            gameContext.input.on('pointerdown', () => {
                var forceMagnitude = 0.005; // Change this value to adjust the force applied
                var angle = this.tankTurret.rotation;
                var force = new Phaser.Math.Vector2(Math.cos(angle) * forceMagnitude, Math.sin(angle) * forceMagnitude);
                tankBody.applyForce(force);
            });
            */
            /*****************************/

            totalRobots++;
            currentRobotIndex++;
        };

        var update = function() {
            for (var i = 0; i < totalRobots; i++) {
                var updateFunction = RobotsData.updateFunctions[i];
                var api = RobotsData.robotAPIs[i];
                updateFunction(api);

                var tankBody = RobotsData.robotBodyImages[i];
                // controlRobotMovement(tankBody, 0.005); // Adjust the speed as needed
                controlRobotMovement(tankBody);
            }
        };

        var controlRobotMovement = function (tankBody) {
            if (tankBody.shouldMove && tankBody.targetPosition) {
                var distance = Phaser.Math.Distance.Between(
                    tankBody.x,
                    tankBody.y,
                    tankBody.targetPosition.x,
                    tankBody.targetPosition.y
                );

                if (distance <= 1) {
                    tankBody.setPosition(tankBody.targetPosition.x, tankBody.targetPosition.y);
                    tankBody.shouldMove = false;
                    tankBody.targetPosition = null;
                    tankBody.setVelocity(0, 0);
                } else {
                    var angle = Phaser.Math.Angle.Between(
                        tankBody.x,
                        tankBody.y,
                        tankBody.targetPosition.x,
                        tankBody.targetPosition.y
                    );
                    var force = new Phaser.Math.Vector2(Math.cos(angle), Math.sin(angle));
                    tankBody.applyForce(force);
                }
            }
        };

        return {
            addRobot: addRobot,
            update: update
        };
    }());

    /****************************************/
    var shredder = (function(robotManager) {

        var update = function(api) {
            api.setAhead(0.5);
        };

        return {
            update: update
        };
    }(robotManager));
    /****************************************/

    var PhysicsHelperFunctions = (function() {

        return {
            // Matter physics does not support tilemap collisions (which is what the arena is made up of).
            // So I created this method with the help of ChatGPT4 which converts the tiles into matter bodies.
            createMatterBodiesFromTilemapLayer: function createMatterBodiesFromTilemapLayer(layer, collisionCategory, collidesWith) {
                const matterBodies = [];
                layer.forEachTile(tile => {
                    if (tile.properties.collides) {
                        const x = tile.getCenterX();
                        const y = tile.getCenterY();
                        const w = tile.width;
                        const h = tile.height;
                        const body = gameContext.matter.add.rectangle(x, y, w, h, { isStatic: true });
                        // body.collisionFilter.category = PhysicsCategories.Walls;
                        // body.collisionFilter.mask = PhysicsCategories.RobotBody;
                        body.collisionFilter.category = collisionCategory;
                        body.collisionFilter.mask = collidesWith;
                        matterBodies.push(body);
                    }
                });

                return matterBodies;
            }
        };
    }());

    var helperFunctions = (function() {

        // Shows collision on a layer with a different color for debugging.
        // TODO: move this function to PhysicsHelperFunctions
        var showDebugLayerCollisions = function(layer) {
            var debugGraphics = gameContext.add.graphics().setAlpha(0.75);
            layer.renderDebug(debugGraphics,
                {
                    tileColor: null, // Color of non-colliding tiles
                    collidingTileColor: new Phaser.Display.Color(243, 134, 48, 255), // Color of colliding tiles
                    faceColor: new Phaser.Display.Color(40, 39, 37, 255) // Color of colliding face edges
                });
        };

        return {
            showDebugLayerCollisions: showDebugLayerCollisions
        };
    }());

    var config = {
        type: Phaser.AUTO,
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        scene: {
            preload: gameManager.preload,
            create: gameManager.create,
            update: gameManager.update
        },
        physics: {
            default: 'matter',
            matter: {
                debug: true,
                gravity: {
                    x: 0,
                    y: 0
                }
            }
        }
    };
    var game = new Phaser.Game(config);
</script>

</body>
</html>