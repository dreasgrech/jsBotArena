<!DOCTYPE html>
<html>
<head>
    <script src="phaser-3.15.1.js"></script>
</head>
<body>

<script>
    var GAME_WIDTH = 1024,
        GAME_HEIGHT = 1024;

    var gameContext;

    const PhysicsCategories = (function() {
        var categories = [
            'RobotBody',
            'RobotTurret',
            'Walls'
        ];

        // Assign the correct 2^n value to each category
        var physicsCategories = {};
        for (var i = 0; i < categories.length; i++) {
            physicsCategories[categories[i]] = Math.pow(2, i);
        }

        return physicsCategories;
    }());

    var RobotAPIFactory = (function() {
        var createAPI = function(robotIndex) {
            return (function(robotIndex) {

                var move = function() {
                    var tankBody = RobotsData.robotBodyImages[robotIndex];
                    var tankSpeed = RobotsData.robotSpeeds[robotIndex];

                    var angle = Phaser.Math.DegToRad(tankBody.angle);
                    var force = new Phaser.Math.Vector2(Math.cos(angle) * tankSpeed, Math.sin(angle) * tankSpeed); // * tankSpeed;
                    tankBody.applyForce(force);
                };

                //var rotateLeft = function() {
                //    var tankBody = RobotsData.robotBodyImages[robotIndex];
                //    var rotationAngle = -30; // change this value to adjust the rotation angle
                //    tankBody.setAngle(tankBody.angle + rotationAngle);
                //};
                var rotateLeft = function() {
                    var tankBody = RobotsData.robotBodyImages[robotIndex];
                    var angularVelocity = -0.05; // change this value to adjust the rotation speed
                
                    tankBody.setAngularVelocity(angularVelocity);
                };

                return {
                    move: move,
                    rotateLeft: rotateLeft
                };
            }(robotIndex));
        };

        return {
            createAPI: createAPI
        };
    }());

    var gameManager = (function() {

        var preload = function() {
            gameContext = this;

            // var floor = this.load.image('arena_floor', 'images/arena_floor.png');
            this.load.image('floor_image', 'images/Floor - Dirt 2 64x64.png');
            this.load.image('wall_image', 'images/Wall - Brick 2 64x64.png');

            this.load.tilemapTiledJSON('arena_json', 'arena_map.json');
        };

        var create = function() {
            // Enable Matter physics
            this.matter.world.setBounds();
            /*
                var floorImage = this.textures.get('arena_floor').getSourceImage();
                var floorImageWidth = floorImage.width;
                var floorImageHeight = floorImage.height;
        
                console.log(floorImageWidth);
                console.log(floorImageHeight);
        
                var posX = 0, posY = 0;
                var floor = this.add.tileSprite(posX, posY, GAME_WIDTH, GAME_HEIGHT, "arena_floor");
                floor.setOrigin(0, 0);
            */

            //this.add.image(0, 0, 'floor');
            var map = this.make.tilemap({ key: 'arena_json' });

            var floorTilesetImage = map.addTilesetImage('Floor', 'floor_image');
            var wallTilesetImage = map.addTilesetImage('Walls', 'wall_image');

            var floorLayer = map.createStaticLayer('Floor Layer', floorTilesetImage);
            var wallsLayer = map.createStaticLayer('Walls Layer', wallTilesetImage);

            // Set collision on the walls
            wallsLayer.setCollisionByProperty({ collides: true });
            PhysicsHelperFunctions.createMatterBodiesFromTilemapLayer(wallsLayer, PhysicsCategories.Walls, PhysicsCategories.RobotBody);
            // var matterBodies = PhysicsHelperFunctions.createMatterBodiesFromTilemapLayer(wallsLayer, PhysicsCategories.Walls, PhysicsCategories.RobotBody);
            //console.log("Wall group: " + matterBodies[0].collisionFilter.group);
            //console.log("Wall category: " + matterBodies[0].collisionFilter.category);
            //console.log("Wall mask: " + matterBodies[0].collisionFilter.mask);

            // helperFunctions.showDebugLayerCollisions(wallsLayer);

            robotManager.addRobot(shredder);
        };


        var update = function(time, delta) {
            robotManager.update(time, delta);
        };

        return {
            preload: preload,
            create: create,
            update: update
        }
    }());

    var RobotsData = (function() {
        var ids = [];
        var positionXs = [];
        var positionYs = [];
        var updateFunctions = [];
        var robotBodyImages = [];
        var robotTurretImages = [];
        var robotAPIs = [];
        var robotSpeeds = [];

        return {
            ids: ids,
            positionXs: positionXs,
            positionYs: positionYs,
            updateFunctions: updateFunctions,
            robotBodyImages: robotBodyImages,
            robotTurretImages: robotTurretImages,
            robotAPIs: robotAPIs,
            robotSpeeds: robotSpeeds
        };
    }());

    var robotManager = (function() {
        var currentRobotIndex = 0;
        var totalRobots = 0;

        var addRobot = function(newRobot) {
            RobotsData.updateFunctions[currentRobotIndex] = newRobot.update;

            /*****************************/
            // Create tank body and turret
            var tankBody = gameContext.matter.add.image(400, 300, 'tankBody');
            tankBody.setAngle(-90);
            tankBody.setFrictionAir(0.2);
            // tankBody.setMass(10);
            tankBody.setMass(100);
            RobotsData.robotBodyImages[currentRobotIndex] = tankBody;
            PhysicsHelperFunctions.setCollisionProperties(tankBody.body, 0, PhysicsCategories.RobotBody, PhysicsCategories.RobotBody | PhysicsCategories.Walls);
            console.log("tank group:" + tankBody.body.collisionFilter.group);
            console.log("tank category:" + tankBody.body.collisionFilter.category);
            console.log("tank mask:" + tankBody.body.collisionFilter.mask);

            /*
            // const tankTurret = this.matter.add.image(400, 300, 'tankTurret');
            var tankTurret = gameContext.matter.add.image(400, 300, 'tankTurret');
            tankTurret.setCollisionCategory(PhysicsCategories.RobotTurret);
            tankTurret.setCollidesWith(0);

            // Set the origin of the turret to the base of the turret
            tankTurret.setOrigin(0.5, 0.75);

            // Create a constraint to attach the turret to the body
            var turretConstraint = gameContext.matter.add.constraint(tankBody, tankTurret, 0, 1);

            RobotsData.robotTurretImages[currentRobotIndex] = tankTurret;
            */

            var api = RobotAPIFactory.createAPI(currentRobotIndex);
            RobotsData.robotAPIs[currentRobotIndex] = api;

            RobotsData.robotSpeeds[currentRobotIndex] = 0.1;

            //// Update the turret rotation based on pointer location
            /*
            gameContext.input.on('pointermove', (pointer) => {
                // const angle = Phaser.Math.Angle.Between(tankTurret.x, tankTurret.y, pointer.x, pointer.y);
                const angle = Phaser.Math.Angle.Between(tankBody.x, tankBody.y, pointer.x, pointer.y);
                // tankTurret.setAngle(Phaser.Math.RadToDeg(angle));
                tankBody.setAngle(Phaser.Math.RadToDeg(angle));
            });
            */

            // Listen for a pointerdown event to apply force to the tank body
            /*
            gameContext.input.on('pointerdown', () => {
                var forceMagnitude = 0.005; // Change this value to adjust the force applied
                var angle = this.tankTurret.rotation;
                var force = new Phaser.Math.Vector2(Math.cos(angle) * forceMagnitude, Math.sin(angle) * forceMagnitude);
                tankBody.applyForce(force);
            });
            */
            /*****************************/

            totalRobots++;
            currentRobotIndex++;
        };

        var update = function(time, delta) {
            for (var i = 0; i < totalRobots; i++) {
                var updateFunction = RobotsData.updateFunctions[i];
                var api = RobotsData.robotAPIs[i];
                updateFunction(api, time, delta);

                /*
                var tankBody = RobotsData.robotBodyImages[i];
                // controlRobotMovement(tankBody, 0.005); // Adjust the speed as needed
                controlRobotMovement(tankBody);
                */
            }
        };

        return {
            addRobot: addRobot,
            update: update
        };
    }());

    /****************************************/
    var shredder = (function(robotManager) {

        var timeElapsed = 0;
        var interval = 3000; // Move for one second, then stop for two seconds
        var rotateTimer = 0;
        var rotateInterval = 1000; // Rotate every one second

        var update = function(api, time, delta) {
            timeElapsed += delta;
            rotateTimer += delta;

            if (rotateTimer >= rotateInterval) {
                api.rotateLeft();
                rotateTimer = 0;
            }

            if (timeElapsed < 1000) { // move
                //api.move();
            } else if (timeElapsed < interval) { // stop
                // Do nothing
            } else { // Move for one second
                timeElapsed = 0;
            }
        };

        return {
            update: update
        };
    }(robotManager));
    /****************************************/

    var PhysicsHelperFunctions = (function() {
        var setCollisionProperties = function(physicsObject, group, category, collidesWithCategories) {
            physicsObject.collisionFilter.group = group;
            physicsObject.collisionFilter.category = category;
            physicsObject.collisionFilter.mask = collidesWithCategories;
        };

        return {
            // Matter physics does not support tilemap collisions (which is what the arena is made up of).
            // So I created this method with the help of ChatGPT4 which converts the tiles into matter bodies.
            createMatterBodiesFromTilemapLayer: function(layer, collisionCategory, collidesWith) {
                const matterBodies = [];
                layer.forEachTile(tile => {
                    if (tile.properties.collides) {
                        const x = tile.getCenterX();
                        const y = tile.getCenterY();
                        const w = tile.width;
                        const h = tile.height;
                        const body = gameContext.matter.add.rectangle(x, y, w, h, { isStatic: true });
                        // body.collisionFilter.category = PhysicsCategories.Walls;
                        // body.collisionFilter.mask = PhysicsCategories.RobotBody;
                        setCollisionProperties(body, 0, collisionCategory, collidesWith);
                        matterBodies.push(body);
                        // console.log("terrain group:" + body.collisionFilter.group);
                    }
                });

                return matterBodies;
            },
            setCollisionProperties: setCollisionProperties
        };
    }());

    var helperFunctions = (function() {

        // Shows collision on a layer with a different color for debugging.
        // TODO: move this function to PhysicsHelperFunctions
        var showDebugLayerCollisions = function(layer) {
            var debugGraphics = gameContext.add.graphics().setAlpha(0.75);
            layer.renderDebug(debugGraphics,
                {
                    tileColor: null, // Color of non-colliding tiles
                    collidingTileColor: new Phaser.Display.Color(243, 134, 48, 255), // Color of colliding tiles
                    faceColor: new Phaser.Display.Color(40, 39, 37, 255) // Color of colliding face edges
                });
        };

        return {
            showDebugLayerCollisions: showDebugLayerCollisions
        };
    }());

    var config = {
        type: Phaser.AUTO,
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        scene: {
            preload: gameManager.preload,
            create: gameManager.create,
            update: gameManager.update
        },
        physics: {
            default: 'matter',
            matter: {
                debug: true,
                gravity: {
                    x: 0,
                    y: 0
                }
            }
        }
    };
    var game = new Phaser.Game(config);
</script>

</body>
</html>